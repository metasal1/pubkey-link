generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Bot {
  id           String          @id @default(cuid())
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  name         String          @unique
  avatarUrl    String?
  status       BotStatus       @default(Active)
  token        String /// @encrypted
  clientId     String /// @encrypted
  clientSecret String /// @encrypted
  community    Community       @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId  String          @unique
  permissions  BotPermission[]
  members      BotMember[]
  servers      BotServer[]
  logs         Log[]
}

model BotServer {
  id        String      @id @default(cuid())
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  bot       Bot         @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId     String
  serverId  String
  name      String
  member    BotMember[]

  @@unique([botId, serverId])
}

model BotMember {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  bot       Bot       @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId     String
  userId    String
  server    BotServer @relation(fields: [botId, serverId], references: [botId, serverId])
  serverId  String

  identity         Identity         @relation(fields: [identityProvider, userId], references: [provider, providerId], onDelete: Cascade)
  identityProvider IdentityProvider @default(Discord)

  @@unique([botId, userId, serverId])
}

model BotPermission {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  bot          Bot              @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId        String
  serverId     String
  serverRoleId String
  roles        RolePermission[]

  @@unique([botId, serverId, serverRoleId])
}

model Community {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  name        String
  avatarUrl   String?
  description String?
  websiteUrl  String?
  discordUrl  String?
  githubUrl   String?
  twitterUrl  String?
  telegramUrl String?
  members     CommunityMember[]
  roles       Role[]
  cluster     NetworkCluster
  bot         Bot?
  logs        Log[]

  @@unique([name])
}

model CommunityMember {
  id          String                @id @default(cuid())
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  role        CommunityRole
  community   Community             @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  roles       CommunityMemberRole[]

  @@unique([communityId, userId])
}

model CommunityMemberRole {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  member    CommunityMember @relation(fields: [memberId], references: [id])
  memberId  String
  role      Role            @relation(fields: [roleId], references: [id])
  roleId    String
}

model Identity {
  id           String              @id @default(cuid())
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  syncStarted  DateTime?
  syncEnded    DateTime?
  provider     IdentityProvider
  providerId   String
  name         String
  accessToken  String? /// @encrypted
  refreshToken String? /// @encrypted
  profile      Json?
  verified     Boolean             @default(false)
  owner        User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId      String
  challenges   IdentityChallenge[]
  bots         BotMember[]
  logs         Log[]

  @@unique([provider, providerId])
}

model IdentityChallenge {
  id         String           @id @default(cuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  challenge  String           @unique
  signature  String?
  ip         String
  userAgent  String
  verified   Boolean          @default(false)
  identity   Identity         @relation(fields: [provider, providerId], references: [provider, providerId], onDelete: Cascade)
  provider   IdentityProvider
  providerId String
}

model Log {
  id                 String            @id @default(cuid())
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  message            String
  data               Json?
  level              LogLevel
  relatedId          String?
  relatedType        LogRelatedType?
  community          Community?        @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId        String?
  identity           Identity?         @relation(fields: [identityProvider, identityProviderId], references: [provider, providerId], onDelete: Cascade)
  identityProvider   IdentityProvider?
  identityProviderId String?
  bot                Bot?              @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId              String?
  networkAsset       NetworkAsset?     @relation(fields: [networkAssetId], references: [id], onDelete: Cascade)
  networkAssetId     String?
  user               User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId             String?
  role               Role?             @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId             String?
}

model Network {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @default(now()) @updatedAt
  cluster   NetworkCluster @unique
  type      NetworkType
  name      String         @unique
  endpoint  String
  assets    NetworkAsset[]
  tokens    NetworkToken[]
}

model NetworkAsset {
  id         String           @id @default(cuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  network    Network          @relation(fields: [cluster], references: [cluster])
  cluster    NetworkCluster
  resolver   NetworkResolver
  type       NetworkTokenType
  account    String
  group      String?
  name       String
  symbol     String?
  balance    String?
  decimals   Int
  mint       String
  owner      String
  program    String?
  imageUrl   String?
  metadata   Json?
  attributes Json?
  logs       Log[]

  @@unique([account, cluster])
  @@index([cluster, owner, type])
  @@index([cluster, group, type])
}

model NetworkToken {
  id          String           @id @default(cuid())
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  network     Network          @relation(fields: [cluster], references: [cluster])
  cluster     NetworkCluster
  type        NetworkTokenType
  name        String
  account     String
  program     String
  vault       String?
  imageUrl    String?
  metadataUrl String?
  description String?
  symbol      String?
  raw         Json?
  conditions  RoleCondition[]

  @@unique([account, cluster])
}

model Role {
  id          String                @id @default(cuid())
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  community   Community             @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  name        String
  description String?
  conditions  RoleCondition[]
  permissions RolePermission[]
  members     CommunityMemberRole[]
  logs        Log[]
}

model RoleCondition {
  id        String           @id @default(cuid())
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  type      NetworkTokenType
  amount    String           @default("0")
  config    Json?
  filters   Json?
  name      String
  token     NetworkToken     @relation(fields: [tokenId], references: [id])
  tokenId   String
  role      Role             @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId    String
}

model RolePermission {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  role      Role           @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId    String
  bot       BotPermission? @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId     String?

  @@unique([roleId, botId])
}

model User {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  avatarUrl   String?
  developer   Boolean           @default(false)
  name        String?
  password    String? /// @encrypted
  role        UserRole          @default(User)
  status      UserStatus        @default(Created)
  username    String            @unique
  communities CommunityMember[]
  identities  Identity[]
  logs        Log[]
}

enum BotStatus {
  Active
  Inactive
}

enum CommunityRole {
  Admin
  Member
}

enum IdentityProvider {
  Discord
  Solana
}

enum LogLevel {
  Error
  Info
  Verbose
  Warning
}

enum LogRelatedType {
  Bot
  BotMember
  Community
  Identity
  Role
  User
}

enum NetworkCluster {
  SolanaCustom
  SolanaDevnet
  SolanaMainnet
  SolanaTestnet
}

enum NetworkResolver {
  Anybodies
  SolanaFungible
  SolanaNonFungible
}

enum NetworkTokenType {
  Fungible
  NonFungible
}

enum NetworkType {
  Solana
}

enum UserRole {
  Admin
  User
}

enum UserStatus {
  Active
  Created
  Inactive
}
